'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = arrayFrom;

var _isArray = require('./isArray');

var _isArray2 = _interopRequireDefault(_isArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create an array from a value
 *
 * @param {*} param Value to transform to an array
 * @param {boolean} [isNewRef] Should return a new reference than the one from the `param` value
 * @returns {Array} The resulting array
 *
 * @requires isArray
 */
function arrayFrom(param, isNewRef) {
    var toArray = function toArray(iterable, start, end) {
        if (!iterable || !iterable.length) {
            return [];
        }

        // FIXME: This will never be called as the if check excludes type string
        if (typeof iterable === 'string') {
            iterable = iterable.split('');
        }

        if (supportsSliceOnNodeList) {
            // FIXME: This does not exist
            return slice.call(iterable, start || 0, end || iterable.length);
        }

        var array = [],
            i;

        // FIXME: start and end are always 0 and iterable.length
        start = start || 0;
        end = end ? end < 0 ? iterable.length + end : end : iterable.length;

        for (i = start; i < end; i++) {
            array.push(iterable[i]);
        }

        return array;
    };

    if (param === undefined || param === null) {
        return [];
    }

    if ((0, _isArray2.default)(param)) {
        return isNewRef ? Array.prototype.slice.call(param) : param;
    }

    var type = typeof param === 'undefined' ? 'undefined' : _typeof(param);
    if (param && param.length !== undefined && type !== 'string' && (type !== 'function' || !param.apply)) {
        // TODO: This function call will always fail because of supportsSliceOnNodeList being undefined
        return toArray(param);
    }

    return [param];
}
//# sourceMappingURL=arrayFrom.js.map